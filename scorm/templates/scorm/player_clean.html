<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ topic.title }} - SCORM Content</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            height: 100vh;
            overflow: hidden;
        }
        
        .scorm-header {
            background: #fff;
            border-bottom: 1px solid #e0e0e0;
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .scorm-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #333;
            margin: 0;
        }
        
        .scorm-info {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.9rem;
            color: #666;
        }
        
        
        .resume-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .resume-content {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .resume-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: #333;
            margin-bottom: 1rem;
        }
        
        .resume-info {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 6px;
            margin: 1rem 0;
            font-size: 0.9rem;
            color: #666;
        }
        
        .resume-actions {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1.5rem;
        }
        
        .btn-resume {
            background: #28a745;
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
        }
        
        .btn-restart {
            background: #6c757d;
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
        }
        
        .btn:hover {
            opacity: 0.9;
        }
        
        .scorm-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background: #007bff;
            color: white;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn:hover {
            opacity: 0.9;
        }
        
        .scorm-container {
            height: calc(100vh - 80px);
            position: relative;
        }
        
        .scorm-iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: white;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.1rem;
            color: #666;
            z-index: 10;
        }
        
        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #dc3545;
            z-index: 10;
        }
        
        .preview-badge {
            background: #ffc107;
            color: #000;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        @media (max-width: 768px) {
            .scorm-header {
                flex-direction: column;
                gap: 1rem;
                align-items: flex-start;
            }
            
            .scorm-info {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="scorm-header">
        <div>
            <h1 class="scorm-title">{{ topic.title }}</h1>
            {% if preview_mode %}
            <div class="scorm-info">
                <span class="preview-badge">PREVIEW MODE</span>
            </div>
            {% endif %}
        </div>
        <div class="scorm-actions">
            <a href="#" id="backToTopicBtn" class="btn btn-secondary" onclick="handleBackToTopic(event); return false;">
                ‚Üê Back to Topic
            </a>
        </div>
    </div>
    

    <div class="scorm-container">
        <div class="loading" id="loading">‚è≥ Loading SCORM content...</div>
        <iframe 
            id="scormFrame"
            class="scorm-iframe" 
            src="{{ content_url }}"
            allow="fullscreen; autoplay; encrypted-media; microphone; camera; picture-in-picture; clipboard-write; clipboard-read; web-share"
            sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox allow-downloads allow-modals allow-presentation allow-top-navigation-by-user-activation"
            referrerpolicy="no-referrer-when-downgrade"
            onload="handleFrameLoad()"
            onerror="handleFrameError()">
        </iframe>
    </div>

    <script>
        // SCORM API Integration
        const API_ENDPOINT = '{{ api_endpoint }}';
        const ATTEMPT_ID = '{{ attempt.id }}';
        const IS_PREVIEW = {{ preview_mode|yesno:"true,false" }};
        
        // Track API calls for debugging
        let apiCallCount = 0;
        
        // SCORM API Implementation with optimized async handling and caching
        const apiCache = new Map();
        const pendingRequests = new Map();
        const CACHE_DURATION = 30000; // 30 seconds cache
        
        function createScormAPI() {
            return {
                Initialize: function(param) {
                    return makeApiCallSync('Initialize', [param]);
                },
                LMSInitialize: function(param) {
                    return makeApiCallSync('LMSInitialize', [param]);
                },
                Terminate: function(param) {
                    return makeApiCallSync('Terminate', [param]);
                },
                LMSFinish: function(param) {
                    return makeApiCallSync('LMSFinish', [param]);
                },
                GetValue: function(element) {
                    return makeApiCallWithCache('GetValue', [element]);
                },
                LMSGetValue: function(element) {
                    return makeApiCallWithCache('LMSGetValue', [element]);
                },
                SetValue: function(element, value) {
                    return makeApiCallSync('SetValue', [element, value]);
                },
                LMSSetValue: function(element, value) {
                    return makeApiCallSync('LMSSetValue', [element, value]);
                },
                Commit: function(param) {
                    return makeApiCallSync('Commit', [param]);
                },
                LMSCommit: function(param) {
                    return makeApiCallSync('LMSCommit', [param]);
                },
                GetLastError: function() {
                    return makeApiCallWithCache('GetLastError', []);
                },
                LMSGetLastError: function() {
                    return makeApiCallWithCache('LMSGetLastError', []);
                },
                GetErrorString: function(errorCode) {
                    return makeApiCallSync('GetErrorString', [errorCode]);
                },
                LMSGetErrorString: function(errorCode) {
                    return makeApiCallSync('LMSGetErrorString', [errorCode]);
                },
                GetDiagnostic: function(errorCode) {
                    return makeApiCallSync('GetDiagnostic', [errorCode]);
                },
                LMSGetDiagnostic: function(errorCode) {
                    return makeApiCallSync('LMSGetDiagnostic', [errorCode]);
                }
            };
        }
        
        // Optimized API call with caching for read-only operations
        function makeApiCallWithCache(method, parameters) {
            const cacheKey = method + '_' + JSON.stringify(parameters);
            
            // CRITICAL FIX: NEVER cache resume-critical data elements
            // These must ALWAYS fetch from backend to ensure resume functionality works
            if (method === 'GetValue' || method === 'LMSGetValue') {
                const element = parameters[0];
                const resumeCriticalElements = [
                    'cmi.core.lesson_location',
                    'cmi.location',
                    'cmi.suspend_data',
                    'cmi.core.entry',
                    'cmi.entry',
                    'cmi.core.lesson_status',
                    'cmi.completion_status',
                    'cmi.success_status'
                ];
                
                if (resumeCriticalElements.includes(element)) {
                    console.log(`[SCORM API] ${method}(${element}) -> NO CACHE (resume-critical)`);
                    // Make API call WITHOUT caching for resume-critical elements
                    return makeApiCallSync(method, parameters);
                }
            }
            
            // Check cache first for non-critical elements
            if (apiCache.has(cacheKey)) {
                const cached = apiCache.get(cacheKey);
                if (Date.now() - cached.timestamp < CACHE_DURATION) {
                    console.log(`[SCORM API] ${method} -> cached result`);
                    return cached.value;
                }
            }
            
            // Check for pending requests
            if (pendingRequests.has(cacheKey)) {
                console.log(`[SCORM API] ${method} -> waiting for pending request`);
                return pendingRequests.get(cacheKey);
            }
            
            // Make API call
            const result = makeApiCallSync(method, parameters);
            
            // Cache the result (only for non-critical elements)
            apiCache.set(cacheKey, {
                value: result,
                timestamp: Date.now()
            });
            
            return result;
        }
        
        // Make API call to Django backend with caching and request deduplication
        async function makeApiCall(method, parameters) {
            try {
                // Create cache key for this request
                const cacheKey = `${method}_${JSON.stringify(parameters)}`;
                
                // CRITICAL FIX: NEVER cache resume-critical data elements
                let isCacheable = false;
                if (['GetValue', 'LMSGetValue', 'GetLastError', 'LMSGetLastError', 'GetErrorString', 'LMSGetErrorString', 'GetDiagnostic', 'LMSGetDiagnostic'].includes(method)) {
                    // Check if this is a resume-critical element
                    if (method === 'GetValue' || method === 'LMSGetValue') {
                        const element = parameters[0];
                        const resumeCriticalElements = [
                            'cmi.core.lesson_location',
                            'cmi.location',
                            'cmi.suspend_data',
                            'cmi.core.entry',
                            'cmi.entry',
                            'cmi.core.lesson_status',
                            'cmi.completion_status',
                            'cmi.success_status'
                        ];
                        
                        if (!resumeCriticalElements.includes(element)) {
                            isCacheable = true;
                        } else {
                            console.log(`[SCORM API] ${method}(${element}) -> NO CACHE (resume-critical)`);
                        }
                    } else {
                        isCacheable = true;
                    }
                    
                    // Check cache first for cacheable operations
                    if (isCacheable && apiCache.has(cacheKey)) {
                        console.log(`[SCORM API] ${method} -> cached result`);
                        return apiCache.get(cacheKey);
                    }
                }
                
                // Check if request is already pending
                if (pendingRequests.has(cacheKey)) {
                    console.log(`[SCORM API] ${method} -> waiting for pending request`);
                    return await pendingRequests.get(cacheKey);
                }
                
                apiCallCount++;
                console.log(`[SCORM API] ${method}(${parameters.join(', ')}) - Call #${apiCallCount}`);
                
                // Create promise for this request
                const requestPromise = (async () => {
                    const response = await fetch(API_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCookie('csrftoken')
                        },
                        body: JSON.stringify({
                            method: method,
                            parameters: parameters
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        console.log(`[SCORM API] ${method} -> ${data.result}`);
                        
                        // Cache read-only results for 30 seconds (but NOT resume-critical elements)
                        if (isCacheable && ['GetValue', 'LMSGetValue', 'GetLastError', 'LMSGetLastError', 'GetErrorString', 'LMSGetErrorString', 'GetDiagnostic', 'LMSGetDiagnostic'].includes(method)) {
                            apiCache.set(cacheKey, data.result);
                            setTimeout(() => apiCache.delete(cacheKey), 30000);
                        }
                        
                        return data.result;
                    } else {
                        console.error(`[SCORM API] ${method} failed: ${data.error}`);
                        return 'false';
                    }
                })();
                
                // Store pending request
                pendingRequests.set(cacheKey, requestPromise);
                
                try {
                    const result = await requestPromise;
                    return result;
                } finally {
                    // Clean up pending request
                    pendingRequests.delete(cacheKey);
                }
                
            } catch (error) {
                console.error(`[SCORM API] ${method} error:`, error);
                return 'false';
            }
        }
        
        // CRITICAL FIX: Enhanced synchronous wrapper for SCORM API calls with proper resume support
        function makeApiCallSync(method, parameters) {
            try {
                // CRITICAL FIX: For ALL API methods that need to persist data, make actual API calls
                // This includes: Initialize, Terminate, Commit, SetValue, GetValue
                const methodsRequiringAPICall = [
                    'Initialize', 'LMSInitialize',
                    'Terminate', 'LMSFinish', 
                    'Commit', 'LMSCommit',
                    'SetValue', 'LMSSetValue',
                    'GetValue', 'LMSGetValue'
                ];
                
                if (methodsRequiringAPICall.includes(method)) {
                    // For GetValue, check cache first
                    if (method === 'GetValue' || method === 'LMSGetValue') {
                        const element = parameters[0];
                        const cacheKey = method + '_' + JSON.stringify(parameters);
                        
                        // Check cache for non-critical elements
                        const resumeCriticalElements = [
                            'cmi.core.lesson_location', 'cmi.location',
                            'cmi.suspend_data', 'cmi.core.entry', 'cmi.entry',
                            'cmi.core.lesson_status', 'cmi.completion_status',
                            'cmi.core.score.raw', 'cmi.score.raw'
                        ];
                        
                        if (!resumeCriticalElements.includes(element) && apiCache.has(cacheKey)) {
                            const cached = apiCache.get(cacheKey);
                            if (Date.now() - cached.timestamp < CACHE_DURATION) {
                                console.log(`[SCORM API] ${method}(${element}) -> cached: ${cached.value}`);
                                return cached.value;
                            }
                        }
                    }
                    
                    // Make synchronous API call using XMLHttpRequest
                    try {
                        const xhr = new XMLHttpRequest();
                        xhr.open('POST', API_ENDPOINT, false); // Synchronous request
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.setRequestHeader('X-CSRFToken', getCookie('csrftoken'));
                        
                        xhr.send(JSON.stringify({
                            method: method,
                            parameters: parameters
                        }));
                        
                        if (xhr.status === 200) {
                            const response = JSON.parse(xhr.responseText);
                            if (response.success) {
                                const result = response.result;
                                
                                // Cache GetValue results
                                if (method === 'GetValue' || method === 'LMSGetValue') {
                                    const element = parameters[0];
                                    const cacheKey = method + '_' + JSON.stringify(parameters);
                                    apiCache.set(cacheKey, {
                                        value: result,
                                        timestamp: Date.now()
                                    });
                                    console.log(`[SCORM API] ${method}(${element}) -> ${result}`);
                                } else if (method === 'SetValue' || method === 'LMSSetValue') {
                                    const element = parameters[0];
                                    const value = parameters[1];
                                    console.log(`[SCORM API] ${method}(${element}, ${value}) -> stored successfully`);
                                } else {
                                    console.log(`[SCORM API] ${method}() -> ${result}`);
                                }
                                
                                return result;
                            } else {
                                console.error(`[SCORM API] ${method} failed: ${response.error}`);
                                return 'false';
                            }
                        } else {
                            console.error(`[SCORM API] ${method} HTTP error: ${xhr.status}`);
                            return 'false';
                        }
                    } catch (e) {
                        console.error(`[SCORM API] ${method} sync error:`, e);
                        return 'false';
                    }
                }
                
                // For methods that don't need API calls, return appropriate default values
                switch(method) {
                    case 'GetLastError':
                    case 'LMSGetLastError':
                        return '0';
                    case 'GetErrorString':
                    case 'LMSGetErrorString':
                    case 'GetDiagnostic':
                    case 'LMSGetDiagnostic':
                        return 'No error';
                    default:
                        return 'false';
                }
            } catch (error) {
                console.error(`[SCORM API] ${method} sync error:`, error);
                return 'false';
            }
        }
        
        // Get CSRF token from cookies
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        
        // Handle iframe load events with better performance
        function handleFrameLoad() {
            const loading = document.getElementById('loading');
            const frame = document.getElementById('scormFrame');
            
            if (loading) {
                loading.style.display = 'none';
            }
            
            if (frame) {
                frame.style.display = 'block';
            }
            
            console.log('SCORM content loaded successfully');
            
            // OPTIMIZATION: Preload only essential data for faster initial load
            setTimeout(() => {
                preloadCommonAPI();
            }, 300); // Faster preloading
            
            // Inject SCORM API into iframe if possible
            try {
                const iframeDoc = frame.contentDocument || frame.contentWindow.document;
                if (iframeDoc) {
                    injectScormAPI(iframeDoc);
                    // Also inject exit button handler
                    injectExitButtonHandler();
                }
            } catch (e) {
                // Cross-origin, can't inject directly
                console.log('Cross-origin iframe, API will be available via parent window');
            }
        }
        
        
        // Disabled asset preloading for better initial load performance
        function preloadSCORMAssets() {
            console.log('SCORM assets will load on demand for better initial performance');
        }
        
        // Simplified API preloading - only essential bookmark data
        function preloadCommonAPI() {
            const essentialCalls = [
                ['GetValue', ['cmi.core.lesson_location']],
                ['GetValue', ['cmi.suspend_data']],
                ['GetValue', ['cmi.core.entry']]
            ];
            
            essentialCalls.forEach(([method, params]) => {
                makeApiCall(method, params).catch(err => {
                    console.log(`Preload ${method} failed:`, err);
                });
            });
        }
        
        // Simplified bookmark preloading - already handled in preloadCommonAPI
        function preloadBookmarkData() {
            console.log('Bookmark data loaded via preloadCommonAPI');
        }
        
        function handleFrameError() {
            const loading = document.getElementById('loading');
            const frame = document.getElementById('scormFrame');
            
            if (loading) {
                loading.innerHTML = 'Failed to load SCORM content';
                loading.className = 'error';
            }
            
            console.error('Failed to load SCORM content');
        }
        
        // Enhanced SCORM API injection into iframe document
        function injectScormAPI(doc) {
            try {
                const api = createScormAPI();
                
                // Set API on iframe window
                const iframeWindow = doc.defaultView || doc.parentWindow;
                if (iframeWindow) {
                    iframeWindow.API = api;
                    iframeWindow.API_1484_11 = api;
                    console.log('SCORM API injected into iframe');
                    
                    // Also inject bookmark data if available
                    injectBookmarkData(iframeWindow);
                    
                    // Add exit button communication helper
                    iframeWindow.scormExit = function() {
                        console.log('SCORM exit called from iframe');
                        try {
                            // Try to save data first
                            if (window.parent && window.parent.API) {
                                if (window.parent.API.LMSCommit) {
                                    window.parent.API.LMSCommit('');
                                }
                                if (window.parent.API.LMSFinish) {
                                    window.parent.API.LMSFinish('');
                                }
                            }
                            
                            // Send exit message to parent
                            window.parent.postMessage({
                                action: 'scorm_exit',
                                type: 'exit_assessment',
                                source: 'iframe'
                            }, '*');
                        } catch (error) {
                            console.error('Error in iframe exit:', error);
                            // Still send message
                            window.parent.postMessage('scorm_exit', '*');
                        }
                    };
                    
                    console.log('SCORM exit helper added to iframe');
                }
            } catch (e) {
                console.log('Could not inject API into iframe:', e.message);
            }
        }
        
        // Inject bookmark data into iframe for immediate access
        function injectBookmarkData(iframeWindow) {
            try {
                // Preload bookmark data and make it available in the iframe
                const bookmarkElements = [
                    'cmi.core.lesson_location',
                    'cmi.location', 
                    'cmi.suspend_data',
                    'cmi.core.entry',
                    'cmi.entry'
                ];
                
                bookmarkElements.forEach(element => {
                    makeApiCall('GetValue', [element]).then(result => {
                        if (result && result !== '') {
                            console.log(`Injecting bookmark data: ${element} = ${result}`);
                            // Store in iframe window for immediate access
                            iframeWindow.scormBookmarkData = iframeWindow.scormBookmarkData || {};
                            iframeWindow.scormBookmarkData[element] = result;
                        }
                    }).catch(err => {
                        console.log(`Bookmark injection failed for ${element}:`, err);
                    });
                });
            } catch (e) {
                console.log('Could not inject bookmark data:', e.message);
            }
        }
        
        // Set up global SCORM API for parent window
        window.API = createScormAPI();
        window.API_1484_11 = createScormAPI();
        
        // OPTIMIZATION: Faster API initialization
        setTimeout(() => {
            if (window.API && !window.API._initialized) {
                console.log('Auto-initializing SCORM API...');
                window.API.LMSInitialize('');
                window.API_1484_11.Initialize('');
                window.API._initialized = true;
            }
        }, 300); // Reduced from 1000ms to 300ms
        
        // CRITICAL FIX: Handle page unload - extract score and save SCORM data
        window.addEventListener('beforeunload', function(e) {
            if (window.API && window.API._initialized) {
                console.log('Page unloading - extracting score and saving SCORM session data...');
                
                try {
                    // CRITICAL: Try to force extract score before terminating
                    forceExtractScore();
                    
                    // First commit any pending data
                    window.API.LMSCommit('');
                    console.log('SCORM Commit called');
                    
                    // Then terminate the session
                    window.API.LMSFinish('');
                    console.log('SCORM LMSFinish called');
                    
                    // Also try SCORM 2004 API
                    if (window.API_1484_11 && window.API_1484_11.Terminate) {
                        window.API_1484_11.Terminate('');
                        console.log('SCORM 2004 Terminate called');
                    }
                } catch (error) {
                    console.error('Error during beforeunload SCORM save:', error);
                }
            }
        });
        
        // CRITICAL FIX: Handle SCORM exit/terminate events (EXIT ASSESSMENT button)
        function handleScormExit() {
            console.log('SCORM Exit Assessment triggered');
            
            // CRITICAL: Try to force extract score before terminating
            forceExtractScore();
            
            // Call SCORM terminate methods
            if (window.API && window.API._initialized) {
                try {
                    console.log('Calling SCORM Commit...');
                    window.API.LMSCommit('');
                    
                    console.log('Calling SCORM Terminate...');
                    const result = window.API.LMSFinish('');
                    console.log('SCORM Terminate result:', result);
                    
                    // Wait a moment for data to be saved
                    setTimeout(() => {
                        console.log('Redirecting to topic view...');
                        // Redirect to topic view
                        window.location.href = '{% url "courses:topic_view" topic.id %}';
                    }, 1000);
                } catch (error) {
                    console.error('SCORM Terminate error:', error);
                    // Still redirect even if terminate fails
                    setTimeout(() => {
                        window.location.href = '{% url "courses:topic_view" topic.id %}';
                    }, 1000);
                }
            } else {
                console.log('SCORM API not initialized, redirecting anyway...');
                window.location.href = '{% url "courses:topic_view" topic.id %}';
            }
        }
        
        // CRITICAL FIX: Force extract score from SCORM API state before exit (SECURE - no iframe access)
        function forceExtractScore() {
            console.log('üîç Attempting to force extract score from SCORM API...');
            
            try {
                let extractedScore = null;
                
                // SECURE Method 1: Read directly from SCORM API's internal cache (same-origin)
                if (window.API && window.API._cache) {
                    const scoreRaw = window.API._cache['cmi.core.score.raw'] || window.API._cache['cmi.score.raw'];
                    if (scoreRaw && scoreRaw !== '') {
                        extractedScore = parseFloat(scoreRaw);
                        console.log(`‚úÖ Found score in API cache: ${extractedScore}`);
                    }
                }
                
                // SECURE Method 2: Try GetValue from SCORM 1.2 API (same-origin)
                if (!extractedScore && window.API && window.API.LMSGetValue) {
                    try {
                        const scoreRaw = window.API.LMSGetValue('cmi.core.score.raw');
                        if (scoreRaw && scoreRaw !== '' && scoreRaw !== 'false') {
                            extractedScore = parseFloat(scoreRaw);
                            console.log(`‚úÖ Found score via LMSGetValue: ${extractedScore}`);
                        }
                    } catch (e) {
                        console.log('LMSGetValue failed:', e.message);
                    }
                }
                
                // SECURE Method 3: Try SCORM 2004 API (same-origin)
                if (!extractedScore && window.API_1484_11 && window.API_1484_11.GetValue) {
                    try {
                        const scoreRaw = window.API_1484_11.GetValue('cmi.score.raw');
                        if (scoreRaw && scoreRaw !== '' && scoreRaw !== 'false') {
                            extractedScore = parseFloat(scoreRaw);
                            console.log(`‚úÖ Found score via SCORM 2004 API: ${extractedScore}`);
                        }
                    } catch (e) {
                        console.log('SCORM 2004 GetValue failed:', e.message);
                    }
                }
                
                // If score found, ensure it's committed to database
                if (extractedScore !== null && extractedScore >= 0 && extractedScore <= 100) {
                    console.log(`üéØ Extracted score from SCORM API: ${extractedScore}`);
                    
                    // Check if this is different from what's already stored
                    let currentScore = null;
                    if (window.API && window.API.LMSGetValue) {
                        try {
                            const stored = window.API.LMSGetValue('cmi.core.score.raw');
                            if (stored && stored !== '' && stored !== 'false') {
                                currentScore = parseFloat(stored);
                            }
                        } catch (e) {}
                    }
                    
                    // Score is already in SCORM API, just make sure it's committed
                    if (currentScore !== null && currentScore === extractedScore) {
                        console.log(`‚úÖ Score ${currentScore} is already set in SCORM API`);
                        // Just commit to ensure it's saved
                        if (window.API && window.API._initialized) {
                            window.API.LMSCommit('');
                            console.log('‚úÖ Score committed to ensure database save');
                        }
                    }
                    
                    return extractedScore;
                } else {
                    console.log('‚ÑπÔ∏è No score found in SCORM API - content may not have reported score yet');
                }
                
                // NOTE: Server-side auto-extraction from suspend_data will handle unreported scores
                console.log('‚ÑπÔ∏è Relying on server-side score extraction from suspend_data');
                
                return extractedScore;
                
            } catch (error) {
                console.error('‚ùå Error extracting score:', error);
                return null;
            }
        }
        
        // FIXED: Handle "Back to Topic" button click - save progress without forcing completion
        function handleBackToTopic(event) {
            event.preventDefault();
            isExiting = true;  // Flag that user is exiting properly
            console.log('üîñ Back to Topic button clicked - saving bookmark data for resume...');
            
            // Show user feedback
            const backBtn = document.getElementById('backToTopicBtn');
            if (backBtn) {
                backBtn.textContent = 'Saving progress...';
                backBtn.classList.add('disabled');
            }
            
            // CRITICAL: Force save current navigation state for resume
            try {
                // Get current iframe location for bookmark
                const iframe = document.getElementById('scormContent');
                if (iframe && iframe.contentWindow) {
                    try {
                        // Try to get current location from iframe
                        const currentUrl = iframe.contentWindow.location.href;
                        const urlParts = currentUrl.split('#');
                        if (urlParts.length > 1) {
                            const bookmark = 'index.html#' + urlParts[1];
                            console.log('üîñ Setting bookmark from iframe URL:', bookmark);
                            
                            // Set lesson location for resume
                            if (window.API && window.API.LMSSetValue) {
                                window.API.LMSSetValue('cmi.core.lesson_location', bookmark);
                            }
                            if (window.API_1484_11 && window.API_1484_11.SetValue) {
                                window.API_1484_11.SetValue('cmi.location', bookmark);
                            }
                        }
                    } catch (e) {
                        console.log('Could not extract iframe location (cross-origin):', e.message);
                    }
                }
            } catch (error) {
                console.log('Bookmark extraction error:', error.message);
            }
            
            // Call SCORM commit (but NOT terminate) to save current progress for resume
            if (window.API && window.API._initialized) {
                try {
                    console.log('üîñ Committing SCORM bookmark data for resume...');
                    // CRITICAL: Force extract current score before committing
                    try {
                        // Try to get current score from SCORM API
                        const scoreRaw12 = window.API.LMSGetValue ? window.API.LMSGetValue('cmi.core.score.raw') : '';
                        const scoreRaw2004 = window.API_1484_11 && window.API_1484_11.GetValue ? 
                            window.API_1484_11.GetValue('cmi.score.raw') : '';
                        const currentScore = scoreRaw12 || scoreRaw2004;
                        
                        if (currentScore && currentScore !== '' && currentScore !== 'false') {
                            console.log('üìä Current score before exit:', currentScore);
                            // Force set the score to ensure it's saved
                            if (window.API.LMSSetValue) {
                                window.API.LMSSetValue('cmi.core.score.raw', currentScore);
                            }
                            if (window.API_1484_11 && window.API_1484_11.SetValue) {
                                window.API_1484_11.SetValue('cmi.score.raw', currentScore);
                            }
                        }
                    } catch (e) {
                        console.log('Could not extract score:', e.message);
                    }
                    
                    // Only commit current data - don't terminate (which triggers completion logic)
                    const commitResult = window.API.LMSCommit('');
                    console.log('SCORM 1.2 Commit result:', commitResult);
                    
                    if (window.API_1484_11 && window.API_1484_11.Commit) {
                        const commitResult2004 = window.API_1484_11.Commit('');
                        console.log('SCORM 2004 Commit result:', commitResult2004);
                    }
                    
                    console.log('‚úÖ SCORM bookmark data saved for resume');
                    scormDataSaved = true;  // Mark that data has been saved
                    
                    // CRITICAL: Trigger backend sync to update TopicProgress with time/attempts
                    fetch('{% url "scorm:sync_on_exit" %}', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'X-CSRFToken': '{{ csrf_token }}'
                        },
                        body: 'attempt_id={{ attempt.id }}'
                    })
                    .then(response => response.json())
                    .then(data => {
                        console.log('üîÑ Backend sync result:', data);
                    })
                    .catch(error => {
                        console.error('‚ùå Backend sync error:', error);
                    })
                    .finally(() => {
                        // Redirect after sync attempt (success or failure)
                        setTimeout(() => {
                            console.log('üîñ Redirecting to topic view...');
                            window.location.href = '{% url "courses:topic_view" topic.id %}';
                        }, 300);
                    });
                } catch (error) {
                    console.error('‚ùå SCORM Commit error:', error);
                    // Still redirect even if commit fails
                    setTimeout(() => {
                        window.location.href = '{% url "courses:topic_view" topic.id %}';
                    }, 300);
                }
            } else {
                console.log('üîñ SCORM API not initialized, triggering backend sync anyway...');
                
                // Still trigger backend sync even if SCORM API wasn't initialized
                fetch('{% url "scorm:sync_on_exit" %}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-CSRFToken': '{{ csrf_token }}'
                    },
                    body: 'attempt_id={{ attempt.id }}'
                })
                .then(response => response.json())
                .then(data => {
                    console.log('üîÑ Backend sync result:', data);
                })
                .catch(error => {
                    console.error('‚ùå Backend sync error:', error);
                })
                .finally(() => {
                    window.location.href = '{% url "courses:topic_view" topic.id %}';
                });
            }
        }
        
        // Enhanced message listener for iframe exit communication
        window.addEventListener('message', function(event) {
            console.log('Received message from iframe:', event.data, 'Origin:', event.origin);
            
            // Handle exit messages from SCORM content
            let shouldExit = false;
            
            if (event.data && typeof event.data === 'string') {
                const message = event.data.toLowerCase();
                // FIXED: Only trigger completion for explicit completion messages, not general exit messages
                if (message === 'complete_assessment' || message === 'lesson_complete' || 
                    message === 'course_complete' || message.includes('quiz_complete') ||
                    message === 'scorm_complete' || message.includes('assessment_complete')) {
                    console.log('Received completion message from SCORM content:', event.data);
                    shouldExit = true;
                } else if (message.includes('exit') || message.includes('terminate') || message.includes('finish')) {
                    // Log exit messages but don't auto-complete unless explicitly marked as completion
                    console.log('Received exit message (not completion) from SCORM content:', event.data);
                    // Don't set shouldExit = true for general exit messages
                }
            } else if (event.data && typeof event.data === 'object') {
                // Handle structured messages - only complete for explicit completion actions
                if (event.data.action === 'complete' || event.data.action === 'course_complete' ||
                    event.data.type === 'assessment_complete' || event.data.type === 'lesson_complete' ||
                    event.data.status === 'completed' || event.data.completed === true) {
                    console.log('Received structured completion message from SCORM content:', event.data);
                    shouldExit = true;
                } else if (event.data.action === 'exit' || event.data.action === 'terminate' || event.data.action === 'finish') {
                    console.log('Received structured exit message (not completion) from SCORM content:', event.data);
                    // Don't set shouldExit = true for general exit messages without completion status
                }
            }
            
            if (shouldExit) {
                console.log('Processing completion request from SCORM content...');
                
                // FIXED: Don't force extract score - let SCORM content report score naturally
                // For real completions, the SCORM content should have already set the score via SetValue
                console.log('SCORM content reports completion - allowing natural score reporting');
                
                // Ensure all SCORM data is saved and properly terminated for completion
                if (window.API && window.API._initialized) {
                    try {
                        console.log('Saving SCORM completion data...');
                        
                        // Force commit any pending data
                        if (window.API.LMSCommit) {
                            window.API.LMSCommit('');
                        }
                        if (window.API_1484_11 && window.API_1484_11.Commit) {
                            window.API_1484_11.Commit('');
                        }
                        
                        // Terminate the session (this should be safe now since it's explicit completion)
                        if (window.API.LMSFinish) {
                            const result = window.API.LMSFinish('');
                            console.log('SCORM LMSFinish result:', result);
                        }
                        if (window.API_1484_11 && window.API_1484_11.Terminate) {
                            window.API_1484_11.Terminate('');
                        }
                        
                        console.log('SCORM completion data saved successfully');
                    } catch (error) {
                        console.error('Error saving SCORM completion data:', error);
                    }
                }
                
                // Redirect to topic view after a short delay to ensure data is saved
                setTimeout(() => {
                    console.log('Redirecting to topic view after completion...');
                    window.location.href = '{% url "courses:topic_view" topic.id %}';
                }, 1000);
            }
        });
        
        // CRITICAL FIX: Prevent window close without saving SCORM data
        let scormDataSaved = false;
        let isExiting = false;
        
        // Add beforeunload event to capture score even when users close browser
        window.addEventListener('beforeunload', function(event) {
            // If user is already exiting properly via Back to Topic, don't interfere
            if (isExiting || scormDataSaved) {
                return;
            }
            
            console.log('üö® User trying to close window - attempting to save SCORM data...');
            
            // Try to save SCORM data immediately
            if (window.API && window.API._initialized) {
                try {
                    // Force extract and save any available score
                    forceExtractScore();
                    
                    // Commit current data
                    window.API.LMSCommit('');
                    if (window.API_1484_11) {
                        window.API_1484_11.Commit('');
                    }
                    
                    console.log('‚úÖ Emergency SCORM data save attempted');
                    scormDataSaved = true;
                    
                    // Also try to force a synchronous API call to ensure data is sent
                    if (navigator.sendBeacon) {
                        navigator.sendBeacon('{% url "scorm:emergency_save" %}', JSON.stringify({
                            attempt_id: '{{ attempt_id }}',
                            action: 'emergency_save',
                            timestamp: new Date().toISOString()
                        }));
                    }
                } catch (error) {
                    console.error('‚ùå Emergency SCORM save failed:', error);
                }
            }
            
            // Show warning message to user  
            const warningMessage = '‚ö†Ô∏è WARNING: Closing this window directly may cause your quiz score and progress to be lost!\\n\\nTo ensure your score is saved properly, please click the "‚Üê Back to Topic" button instead.\\n\\nDo you really want to close without saving?';
            
            // Set the beforeunload message (browsers will show their own dialog)
            event.preventDefault();
            event.returnValue = warningMessage;
            return warningMessage;
        });
        
        // Handle page visibility changes (when user switches tabs, etc.)
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && !scormDataSaved && !isExiting) {
                console.log('üëÅÔ∏è Page hidden - saving SCORM progress...');
                
                // Try to save current progress when page becomes hidden
                if (window.API && window.API._initialized) {
                    try {
                        window.API.LMSCommit('');
                        if (window.API_1484_11) {
                            window.API_1484_11.Commit('');
                        }
                        console.log('‚úÖ Progress saved on page hide');
                    } catch (error) {
                        console.error('‚ùå Failed to save on page hide:', error);
                    }
                }
            }
        });
        
        // Make handleScormExit available globally for SCORM content to call
        window.handleScormExit = handleScormExit;
        
        // Focus on iframe content - no global handlers needed
        
        // CRITICAL FIX: Enhanced EXIT ASSESSMENT button handling
        function handleExitButtonClicks() {
            // Function to find and fix exit buttons
            function fixExitButtons() {
                // Look for various exit button patterns - expanded list
                const exitButtonSelectors = [
                    '.courseExit',
                    '.courseExit--standard',
                    'button[class*="exit"]',
                    'button[class*="Exit"]',
                    'button:contains("EXIT")',
                    'button:contains("Exit")',
                    'button:contains("exit")',
                    'input[type="button"][value*="EXIT"]',
                    'input[type="button"][value*="Exit"]',
                    'input[type="button"][value*="exit"]',
                    'a[class*="exit"]',
                    'a:contains("EXIT")',
                    'a:contains("Exit")',
                    'a:contains("exit")',
                    '[data-action="exit"]',
                    '[data-exit="true"]',
                    '.exit-button',
                    '.exit-btn',
                    '#exit-button',
                    '#exit-btn'
                ];
                
                let buttonsFound = 0;
                
                exitButtonSelectors.forEach(selector => {
                    try {
                        const buttons = document.querySelectorAll(selector);
                        buttons.forEach(button => {
                            // Check if button text contains "EXIT" or "Exit"
                            const buttonText = button.textContent || button.value || '';
                            if (buttonText.toLowerCase().includes('exit') || 
                                button.classList.contains('courseExit') ||
                                button.classList.contains('courseExit--standard')) {
                                
                                console.log('Found exit button:', button);
                                buttonsFound++;
                                
                                // Remove any existing click handlers to avoid conflicts
                                const newButton = button.cloneNode(true);
                                button.parentNode.replaceChild(newButton, button);
                                
                                // Add our click handler with enhanced error handling
                                newButton.addEventListener('click', function(e) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    
                                    console.log('EXIT ASSESSMENT button clicked - Enhanced handler');
                                    
                                    // Show user feedback
                                    const originalText = newButton.textContent || newButton.value;
                                    newButton.textContent = 'Exiting...';
                                    newButton.disabled = true;
                                    
                                    // Call SCORM API terminate functions with retry logic
                                    let terminateAttempts = 0;
                                    const maxAttempts = 3;
                                    
                                    function attemptTerminate() {
                                        terminateAttempts++;
                                        console.log(`SCORM Terminate attempt ${terminateAttempts}/${maxAttempts}`);
                                        
                                        if (window.API && window.API._initialized) {
                                            try {
                                                // Call both SCORM 1.2 and 2004 APIs
                                                const result1 = window.API.LMSFinish('');
                                                console.log('SCORM 1.2 LMSFinish result:', result1);
                                                
                                                if (window.API_1484_11) {
                                                    const result2 = window.API_1484_11.Terminate('');
                                                    console.log('SCORM 2004 Terminate result:', result2);
                                                }
                                                
                                                // Force commit any pending data
                                                if (window.API.LMSCommit) {
                                                    window.API.LMSCommit('');
                                                }
                                                if (window.API_1484_11 && window.API_1484_11.Commit) {
                                                    window.API_1484_11.Commit('');
                                                }
                                                
                                                console.log('SCORM Terminate successful, redirecting...');
                                                setTimeout(() => {
                                                    window.location.href = '{% url "courses:topic_view" topic.id %}';
                                                }, 500);
                                                
                                            } catch (error) {
                                                console.error(`SCORM Terminate attempt ${terminateAttempts} failed:`, error);
                                                
                                                if (terminateAttempts < maxAttempts) {
                                                    setTimeout(attemptTerminate, 1000);
                                                } else {
                                                    console.log('Max terminate attempts reached, redirecting anyway...');
                                                    setTimeout(() => {
                                                        window.location.href = '{% url "courses:topic_view" topic.id %}';
                                                    }, 500);
                                                }
                                            }
                                        } else {
                                            console.log('SCORM API not initialized, redirecting anyway...');
                                            setTimeout(() => {
                                                window.location.href = '{% url "courses:topic_view" topic.id %}';
                                            }, 500);
                                        }
                                    }
                                    
                                    // Start the terminate process
                                    attemptTerminate();
                                });
                                
                                console.log('Exit button handler attached successfully');
                            }
                        });
                    } catch (e) {
                        // Ignore selector errors
                    }
                });
                
                if (buttonsFound > 0) {
                    console.log(`Fixed ${buttonsFound} exit button(s)`);
                }
            }
            
            // Run immediately
            fixExitButtons();
            
            // OPTIMIZATION: Run periodically but less frequently (every 5 seconds instead of 2)
            setInterval(fixExitButtons, 5000);
            
            // OPTIMIZATION: Simplified MutationObserver with debouncing
            if (window.MutationObserver) {
                let debounceTimer;
                const observer = new MutationObserver(function(mutations) {
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(fixExitButtons, 500);
                });
                
                observer.observe(document.body, {
                    childList: true,
                    subtree: true
                });
            }
        }
        
        // Enhanced exit button handler injection for iframe content
        function injectExitButtonHandler() {
            try {
                const iframe = document.getElementById('scormFrame');
                if (iframe && iframe.contentDocument) {
                    const iframeDoc = iframe.contentDocument;
                    const iframeWindow = iframe.contentWindow;
                    
                    // Inject comprehensive exit button handler script
                    const script = iframeDoc.createElement('script');
                    script.textContent = `
                        (function() {
                            console.log('SCORM Exit Button Handler injected into iframe');
                            
                            // Enhanced exit button detection and handling
                            function handleExitButtons() {
                                function findAndFixExitButtons() {
                                    const exitSelectors = [
                                        '.courseExit',
                                        '.courseExit--standard',
                                        'button[class*="exit"]',
                                        'button[class*="Exit"]',
                                        'button:contains("EXIT")',
                                        'button:contains("Exit")',
                                        'button:contains("exit")',
                                        'input[type="button"][value*="EXIT"]',
                                        'input[type="button"][value*="Exit"]',
                                        'input[type="button"][value*="exit"]',
                                        'a[class*="exit"]',
                                        'a:contains("EXIT")',
                                        'a:contains("Exit")',
                                        'a:contains("exit")',
                                        '[data-action="exit"]',
                                        '[data-exit="true"]',
                                        '.exit-button',
                                        '.exit-btn',
                                        '#exit-button',
                                        '#exit-btn'
                                    ];
                                    
                                    let buttonsFound = 0;
                                    
                                    exitSelectors.forEach(selector => {
                                        try {
                                            const buttons = document.querySelectorAll(selector);
                                            buttons.forEach(button => {
                                                const buttonText = button.textContent || button.value || '';
                                                if (buttonText.toLowerCase().includes('exit') || 
                                                    button.classList.contains('courseExit') ||
                                                    button.classList.contains('courseExit--standard') ||
                                                    button.getAttribute('data-action') === 'exit' ||
                                                    button.getAttribute('data-exit') === 'true') {
                                                    
                                                    console.log('Found exit button in iframe:', button);
                                                    buttonsFound++;
                                                    
                                                    // Remove existing handlers and add new one
                                                    const newButton = button.cloneNode(true);
                                                    button.parentNode.replaceChild(newButton, button);
                                                    
                                                    newButton.addEventListener('click', function(e) {
                                                        e.preventDefault();
                                                        e.stopPropagation();
                                                        
                                                        console.log('EXIT ASSESSMENT button clicked in iframe');
                                                        
                                                        // Show user feedback
                                                        const originalText = newButton.textContent || newButton.value;
                                                        newButton.textContent = 'Exiting...';
                                                        newButton.disabled = true;
                                                        
                                                        // Call SCORM API to save data
                                                        try {
                                                            // Try to call parent window's SCORM API
                                                            if (window.parent && window.parent.API) {
                                                                console.log('Calling parent SCORM API...');
                                                                
                                                                // Save current progress
                                                                if (window.parent.API.LMSCommit) {
                                                                    window.parent.API.LMSCommit('');
                                                                }
                                                                
                                                                // Terminate session
                                                                if (window.parent.API.LMSFinish) {
                                                                    const result = window.parent.API.LMSFinish('');
                                                                    console.log('SCORM LMSFinish result:', result);
                                                                }
                                                                
                                                                // Also try SCORM 2004 API
                                                                if (window.parent.API_1484_11 && window.parent.API_1484_11.Terminate) {
                                                                    window.parent.API_1484_11.Terminate('');
                                                                }
                                                                
                                                                // Send message to parent to handle redirect
                                                                window.parent.postMessage({
                                                                    action: 'scorm_exit',
                                                                    type: 'exit_assessment'
                                                                }, '*');
                                                                
                                                                console.log('SCORM data saved, redirecting...');
                                                            } else {
                                                                console.log('Parent SCORM API not available, sending exit message...');
                                                                window.parent.postMessage('scorm_exit', '*');
                                                            }
                                                        } catch (error) {
                                                            console.error('Error calling SCORM API:', error);
                                                            // Still send exit message
                                                            window.parent.postMessage('scorm_exit', '*');
                                                        }
                                                    });
                                                    
                                                    console.log('Exit button handler attached in iframe');
                                                }
                                            });
                                        } catch (e) {
                                            // Ignore selector errors
                                        }
                                    });
                                    
                                    if (buttonsFound > 0) {
                                        console.log('Fixed ' + buttonsFound + ' exit button(s) in iframe');
                                    }
                                }
                                
                                // Run immediately
                                findAndFixExitButtons();
                                
                                // OPTIMIZATION: Check less frequently (every 5 seconds)
                                setInterval(findAndFixExitButtons, 5000);
                                
                                // OPTIMIZATION: Debounced MutationObserver
                                if (window.MutationObserver) {
                                    let debounceTimer;
                                    const observer = new MutationObserver(function(mutations) {
                                        clearTimeout(debounceTimer);
                                        debounceTimer = setTimeout(findAndFixExitButtons, 500);
                                    });
                                    
                                    observer.observe(document.body, {
                                        childList: true,
                                        subtree: true
                                    });
                                }
                            }
                            
                            // Start the exit button handler
                            handleExitButtons();
                        })();
                    `;
                    iframeDoc.head.appendChild(script);
                    
                    console.log('Enhanced exit button handler injected into iframe');
                }
            } catch (e) {
                console.log('Could not inject exit button handler into iframe (cross-origin):', e.message);
            }
        }
        
        
        // =================================================================
        // ENHANCED CLIENT-SIDE TIME TRACKING
        // Tracks time even when SCORM content doesn't report it
        // =================================================================
        
        (function() {
            let sessionStartTime = new Date();
            let totalActiveSeconds = 0;
            let lastHeartbeatTime = new Date();
            let isPageVisible = !document.hidden;
            let heartbeatInterval = null;
            let lastSyncTime = null;
            
            console.log('‚è±Ô∏è Client-side time tracking initialized');
            
            // Track page visibility changes
            document.addEventListener('visibilitychange', function() {
                if (document.hidden) {
                    // Page became hidden - pause time tracking
                    isPageVisible = false;
                    
                    const now = new Date();
                    const activeSeconds = Math.floor((now - lastHeartbeatTime) / 1000);
                    if (activeSeconds > 0 && activeSeconds < 300) { // Cap at 5 minutes
                        totalActiveSeconds += activeSeconds;
                    }
                    
                    console.log('‚è∏Ô∏è Time tracking paused (tab hidden). Active time: ' + formatTimeDisplay(totalActiveSeconds));
                } else {
                    // Page became visible - resume time tracking
                    isPageVisible = true;
                    lastHeartbeatTime = new Date();
                    console.log('‚ñ∂Ô∏è Time tracking resumed (tab visible)');
                }
            });
            
            // Heartbeat: Update time every 30 seconds
            heartbeatInterval = setInterval(function() {
                if (isPageVisible) {
                    const now = new Date();
                    const activeSeconds = Math.floor((now - lastHeartbeatTime) / 1000);
                    
                    if (activeSeconds > 0 && activeSeconds < 60) { // Only add reasonable increments
                        totalActiveSeconds += activeSeconds;
                        lastHeartbeatTime = now;
                        
                        console.log('‚è±Ô∏è Time tracking heartbeat: ' + formatTimeDisplay(totalActiveSeconds));
                        
                        // Sync to server every 5 minutes
                        if (!lastSyncTime || (now - lastSyncTime) > 300000) {
                            syncTimeToServer();
                            lastSyncTime = now;
                        }
                    } else if (activeSeconds >= 60) {
                        // Large time gap detected - user probably idle
                        lastHeartbeatTime = now;
                    }
                }
            }, 30000); // Every 30 seconds
            
            // Sync time to server via custom endpoint
            function syncTimeToServer() {
                if (IS_PREVIEW) {
                    console.log('‚è±Ô∏è Preview mode - skipping time sync');
                    return;
                }
                
                const scormTime = formatScormTime(totalActiveSeconds);
                console.log('‚è±Ô∏è Syncing time to server: ' + scormTime);
                
                // Send time via SCORM API if not already set by content
                try {
                    // Check if SCORM content has set session_time
                    const currentSessionTime = window.API ? window.API.GetValue('cmi.core.session_time') : '';
                    
                    if (!currentSessionTime || currentSessionTime === '' || currentSessionTime === '0000:00:00.00') {
                        // SCORM content hasn't set time - use our tracking
                        console.log('‚è±Ô∏è SCORM content not reporting time - using client-side tracking');
                        
                        if (window.API && window.API._initialized) {
                            // Set the session time
                            window.API.SetValue('cmi.core.session_time', scormTime);
                            window.API.LMSCommit('');
                            
                            console.log('‚úÖ Time synced to SCORM: ' + scormTime);
                        }
                    } else {
                        console.log('‚úì SCORM content is reporting time: ' + currentSessionTime);
                    }
                } catch (error) {
                    console.error('‚ùå Error syncing time:', error);
                }
            }
            
            // Format seconds into SCORM time format (hhhh:mm:ss.ss)
            function formatScormTime(totalSeconds) {
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                return String(hours).padStart(4, '0') + ':' +
                       String(minutes).padStart(2, '0') + ':' +
                       String(seconds).padStart(2, '0') + '.00';
            }
            
            // Format for display
            function formatTimeDisplay(totalSeconds) {
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;
                
                if (hours > 0) {
                    return hours + 'h ' + minutes + 'm ' + seconds + 's';
                } else if (minutes > 0) {
                    return minutes + 'm ' + seconds + 's';
                } else {
                    return seconds + 's';
                }
            }
            
            // Final sync on page unload
            window.addEventListener('beforeunload', function() {
                // Final time calculation
                if (isPageVisible) {
                    const now = new Date();
                    const activeSeconds = Math.floor((now - lastHeartbeatTime) / 1000);
                    if (activeSeconds > 0 && activeSeconds < 300) {
                        totalActiveSeconds += activeSeconds;
                    }
                }
                
                console.log('‚è±Ô∏è Final time sync on exit: ' + formatTimeDisplay(totalActiveSeconds));
                syncTimeToServer();
            });
            
            // Also sync when SCORM API terminates
            const originalTerminate = window.API ? window.API.Terminate : null;
            const originalLMSFinish = window.API ? window.API.LMSFinish : null;
            
            if (window.API) {
                window.API.Terminate = function(param) {
                    syncTimeToServer();
                    return originalTerminate ? originalTerminate.call(this, param) : 'true';
                };
                
                window.API.LMSFinish = function(param) {
                    syncTimeToServer();
                    return originalLMSFinish ? originalLMSFinish.call(this, param) : 'true';
                };
            }
            
            console.log('‚úÖ Enhanced time tracking active - will sync every 5 minutes');
        })();
        
        // Debug info for instructors
        {% if is_instructor_or_admin %}
        console.log('SCORM Debug Info:');
        console.log('  Attempt ID:', ATTEMPT_ID);
        console.log('  API Endpoint:', API_ENDPOINT);
        console.log('  Preview Mode:', IS_PREVIEW);
        console.log('  Content URL:', '{{ content_url }}');
        {% endif %}
    </script>
</body>
</html>
