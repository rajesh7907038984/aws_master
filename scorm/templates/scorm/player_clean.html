<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- Load static files first -->
    {% load static %}
    
    <title>{{ topic.title }} - SCORM Content</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #f5f5f5;
        }
        
        
        .scorm-header {
            background: white;
            padding: 1rem;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .scorm-title { margin: 0; color: #333; font-size: 1.2rem; }
        .scorm-actions { display: flex; gap: 0.5rem; }
        .btn { padding: 0.5rem 1rem; border: none; border-radius: 4px; cursor: pointer; text-decoration: none; font-size: 0.9rem; transition: background-color 0.2s; }
        .btn-secondary { background: #6c757d; color: white; }
        .btn-secondary:hover { background: #5a6268; }
        .scorm-container { height: calc(100vh - 80px); position: relative; }
        .scorm-iframe { width: 100%; height: 100%; border: none; display: none; }
        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.1rem; color: #666; }
        .error { color: #dc3545; }
        @media (max-width: 768px) { .scorm-header { flex-direction: column; gap: 0.5rem; } }
        .disabled { opacity: 0.6; pointer-events: none; }
        .debug { position: fixed; right: 8px; bottom: 8px; background: rgba(0,0,0,0.6); color: white; padding: 8px; border-radius: 6px; font-size: 12px; max-width: 320px; z-index: 9999; }
        
    
    </style>
</head>
<body>
    <div class="scorm-header">
        <div>
            <h1 class="scorm-title">{{ topic.title }}</h1>
            {% if preview_mode %}
            <div class="scorm-info"><span class="preview-badge">PREVIEW MODE</span></div>
            {% endif %}
        </div>
        <div class="scorm-actions">
            <a href="#" id="backToTopicBtn" class="btn btn-secondary" onclick="handleBackToTopic(event); return false;">‚Üê Back to Topic</a>
        </div>
    </div>

    {% csrf_token %}

    <div class="scorm-container">
        <div class="loading" id="loading">‚è≥ Loading SCORM content...</div>
        <iframe 
            id="scormFrame"
            class="scorm-iframe" 
            src="{{ content_url }}"
            allow="fullscreen; autoplay; encrypted-media; microphone; camera; picture-in-picture; clipboard-write; clipboard-read; web-share"
            sandbox="allow-same-origin allow-scripts allow-forms allow-popups allow-downloads allow-modals allow-presentation allow-top-navigation allow-pointer-lock allow-orientation-lock allow-popups-to-escape-sandbox"
            referrerpolicy="no-referrer-when-downgrade"
            onload="handleFrameLoad()"
            onerror="handleFrameError()">
        </iframe>
    </div>

    <div id="debug" class="debug" style="display:none"></div>

    <script>
    
   
    // Monitor CSP violations
    document.addEventListener('securitypolicyviolation', function(e) {
        console.log('üö® CSP Violation:', e.violatedDirective, 'Blocked:', e.blockedURI);
    });
    
    // -----------------------
    // Configuration / helpers
    // -----------------------
    const apiEndpoint = '{{ api_endpoint }}'; // Django endpoint that accepts SCORM API calls
    let csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value;
    if (!csrfToken) {
        const cookies = document.cookie.split(';');
        for (let cookie of cookies) {
            const [name, value] = cookie.trim().split('=');
            if (name === 'csrftoken') { csrfToken = value; break; }
        }
    }

    function debugLog(...args) {
        // Toggle debug UI by setting showDebug to true
        const showDebug = false;
        if (!showDebug) return;
        const el = document.getElementById('debug');
        if (el) { el.style.display = 'block'; el.textContent = args.map(x => (typeof x === 'object' ? JSON.stringify(x) : String(x))).join(' | '); }
        console.debug(...args);
    }

    // -----------------------
    // UI: iframe load/error
    // -----------------------
    function handleFrameLoad() {
        const loading = document.getElementById('loading');
        const frame = document.getElementById('scormFrame');
        if (loading) loading.style.display = 'none';
        if (frame) frame.style.display = 'block';
        debugLog('iframe loaded');
    }
    function handleFrameError() {
        const loading = document.getElementById('loading');
        if (loading) {
            loading.innerHTML = `\n                <div style="color: #ff6b6b; text-align: center; padding: 20px;">\n                    <h3>Failed to Load SCORM Content</h3>\n                    <p>This could be due to:</p>\n                    <ul style="text-align: left; display: inline-block;">\n                        <li>Network connectivity issues</li>\n                        <li>Content server problems</li>\n                        <li>Browser security restrictions</li>\n                    </ul>\n                    <button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">\n                        Retry Loading\n                    </button>\n                </div>\n            `;
            loading.className = 'error';
        }
    }

    // -----------------------
    // Robust API discovery
    // -----------------------
    function findAPI(win) {
        let depth = 0;
        try {
            while (win && depth < 20) {
                if (win.API) return win.API;
                if (win.parent === win) break;
                win = win.parent;
                depth++;
            }
        } catch (e) { /* cross-origin */ }
        return null;
    }
    function findAPI_2004(win) {
        let depth = 0;
        try {
            while (win && depth < 20) {
                if (win.API_1484_11) return win.API_1484_11;
                if (win.parent === win) break;
                win = win.parent;
                depth++;
            }
        } catch (e) { /* cross-origin */ }
        return null;
    }

    // Expose our API objects (if a parent frame or content searches upward it will find these on this window)
    // We'll implement the API below and then assign to window.API / window.API_1484_11.

    // -----------------------
    // Local SCORM data store
    // -----------------------
    // Keep a local mirror of cmi.* data so LMSGetValue can return quickly.
    const scormData = {
        // common keys prefilled
        'cmi.core.lesson_status': 'not attempted',
        'cmi.core.score.raw': '',
        'cmi.core.session_time': 'PT0H0M0S',
        'cmi.completion_status': 'unknown',
        'cmi.success_status': 'unknown',
        // add others as values are set
    };

    let lastError = '0';

    // -----------------------
    // Backend communication
    // -----------------------
    function safeJSONStringify(obj) {
        try { return JSON.stringify(obj); } catch (e) { return '{}'; }
    }

    // Primary method to send SCORM method calls to the Django backend.
    // Enhanced with retry logic and better error handling
    function callBackend(method, parameters = [], retryCount = 0) {
        const payload = { method, parameters, scormData };
        debugLog('callBackend', payload);

        // Try sendBeacon for non-blocking reliability (good for Commit/Finish)
        try {
            if (navigator.sendBeacon && (method === 'Commit' || method === 'Terminate' || method === 'Finish')) {
                const blob = new Blob([safeJSONStringify(payload)], { type: 'application/json' });
                const ok = navigator.sendBeacon(apiEndpoint, blob);
                debugLog('sendBeacon result', ok);
                if (ok) {
                    return 'true';
                } else if (retryCount < 2) {
                    // Retry with XHR if sendBeacon fails
                    return callBackend(method, parameters, retryCount + 1);
                }
                return 'false';
            }
        } catch (e) { 
            debugLog('sendBeacon failed', e);
            if (retryCount < 2) {
                return callBackend(method, parameters, retryCount + 1);
            }
        }

        // Enhanced synchronous XHR with retry logic
        try {
            const xhr = new XMLHttpRequest();
            xhr.open('POST', apiEndpoint, false); // synchronous by design for SCORM
            xhr.setRequestHeader('Content-Type', 'application/json');
            if (csrfToken) xhr.setRequestHeader('X-CSRFToken', csrfToken);
            
            // Note: Cannot set timeout on synchronous requests - this causes InvalidAccessError
            // Timeout handling is not available for synchronous XMLHttpRequest calls
            // The synchronous nature is required for SCORM compliance
            
            xhr.send(safeJSONStringify(payload));
            
            if (xhr.status === 200) {
                try {
                    const resp = JSON.parse(xhr.responseText);
                    if (resp && resp.success) {
                        // Allow backend to send back values e.g. GetValue responses
                        return resp.result !== undefined ? resp.result : 'true';
                    } else {
                        console.error('SCORM API error:', resp.error || 'Unknown error');
                        // Retry on error if we haven't exceeded retry limit
                        if (retryCount < 2) {
                            console.log(`Retrying SCORM API call for ${method} (attempt ${retryCount + 1})`);
                            return callBackend(method, parameters, retryCount + 1);
                        }
                    }
                    return 'false';
                } catch (e) { 
                    console.error('SCORM API response parse error:', e);
                    if (retryCount < 2) {
                        return callBackend(method, parameters, retryCount + 1);
                    }
                    return 'false'; 
                }
            } else {
                console.error('SCORM API HTTP error:', xhr.status, xhr.statusText);
                // Retry on HTTP errors
                if (retryCount < 2) {
                    return callBackend(method, parameters, retryCount + 1);
                }
            }
            return 'false';
        } catch (e) {
            console.error('SCORM API Exception:', e);
            // Retry on network errors
            if (retryCount < 2) {
                console.log(`Retrying SCORM API call for ${method} due to network error (attempt ${retryCount + 1})`);
                return callBackend(method, parameters, retryCount + 1);
            }
            return 'false';
        }
    }

    // -----------------------
    // SCORM API implementation
    // -----------------------
    const SCORM_API = {
        // SCORM 1.2 API
        LMSInitialize: function(param) {
            debugLog('LMSInitialize', param);
            lastError = '0';
            // mark initialized
            scormData['cmi.core.lesson_status'] = scormData['cmi.core.lesson_status'] || 'incomplete';
            callBackend('Initialize', [param]);
            return 'true';
        },
        LMSFinish: function(param) {
            debugLog('LMSFinish', param);
            callBackend('Terminate', [param]);
            return 'true';
        },
        LMSGetValue: function(element) {
            debugLog('LMSGetValue', element);
            // Prefer local store
            if (scormData.hasOwnProperty(element)) return scormData[element] || '';
            // Ask backend synchronously if not present
            const resp = callBackend('GetValue', [element]);
            if (resp && resp !== 'false') {
                // backend may return real value
                try { scormData[element] = resp; } catch (e) {}
                return resp;
            }
            return '';
        },
        LMSSetValue: function(element, value) {
            debugLog('LMSSetValue', element, value);
            try { scormData[element] = value; } catch (e) {}
            // send async commit for this set (we use synchronous call to keep SCORM packages happy)
            const resp = callBackend('SetValue', [element, value]);
            return resp === 'true' || resp === true ? 'true' : 'false';
        },
        LMSCommit: function(param) {
            debugLog('LMSCommit', param);
            const resp = callBackend('Commit', [param]);
            if (resp !== 'true') {
                console.error('SCORM Commit failed:', resp);
                // Retry commit once more
                setTimeout(() => {
                    const retryResp = callBackend('Commit', [param]);
                    if (retryResp !== 'true') {
                        console.error('SCORM Commit retry failed:', retryResp);
                        // Try emergency save
                        try {
                            fetch(apiEndpoint.replace('/api/', '/api/emergency-save/'), {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': csrfToken
                                },
                                body: JSON.stringify({
                                    action: 'emergency_commit',
                                    attempt_id: apiEndpoint.split('/').slice(-2, -1)[0]
                                })
                            }).catch(e => console.error('Emergency save failed:', e));
                        } catch (e) {
                            console.error('Emergency save setup failed:', e);
                        }
                    }
                }, 1000);
            }
            return resp === 'true' || resp === true ? 'true' : 'false';
        },
        LMSGetLastError: function() { return lastError; },
        LMSGetErrorString: function(errorCode) { return `Error ${errorCode}`; },
        LMSGetDiagnostic: function(errorCode) { return `Diagnostic for ${errorCode}`; },

        // SCORM 2004 aliases will be attached later
    };

    // Add 2004 equivalents
    const API_2004 = {
        Initialize: function(param) { return SCORM_API.LMSInitialize(param); },
        Terminate: function(param) { return SCORM_API.LMSFinish(param); },
        GetValue: function(element) { return SCORM_API.LMSGetValue(element); },
        SetValue: function(element, value) { return SCORM_API.LMSSetValue(element, value); },
        Commit: function(param) { return SCORM_API.LMSCommit(param); },
        GetLastError: function() { return SCORM_API.LMSGetLastError(); },
        GetErrorString: function(code) { return SCORM_API.LMSGetErrorString(code); },
        GetDiagnostic: function(code) { return SCORM_API.LMSGetDiagnostic(code); }
    };

    // Expose to window so courses inside the iframe can find it by searching parent chain
    window.API = window.API || SCORM_API;
    window.API_1484_11 = window.API_1484_11 || API_2004;

    // Mark initialized flags
    window.API._initialized = true;
    window.API_1484_11._initialized = true;

    // -----------------------
    // Message listener for iframe-to-LMS communication
    // Supports: scorm_content postMessage, Storyline custom messages, xAPI hints
    // -----------------------
    window.addEventListener('message', function(event) {
        // You may restrict origin check here to the content domain
        try {
            const data = event.data;
            if (!data) return;

            // 1) If content uses our agreed scorm_content protocol
            if (data.source === 'scorm_content') {
                const { action, data: payload, id } = data;
                let result = 'false';
                let error = null;
                try {
                    switch (action) {
                        case 'scorm_initialize': result = SCORM_API.LMSInitialize(payload); break;
                        case 'scorm_terminate': result = SCORM_API.LMSFinish(payload); break;
                        case 'scorm_get_value': result = SCORM_API.LMSGetValue(payload); break;
                        case 'scorm_set_value': result = SCORM_API.LMSSetValue(payload.element, payload.value); break;
                        case 'scorm_commit': result = SCORM_API.LMSCommit(payload); break;
                        case 'scorm_get_last_error': result = SCORM_API.LMSGetLastError(); break;
                        case 'scorm_get_error_string': result = SCORM_API.LMSGetErrorString(payload); break;
                        case 'scorm_get_diagnostic': result = SCORM_API.LMSGetDiagnostic(payload); break;
                        default: error = 'Unknown action: ' + action;
                    }
                } catch (e) { error = e && e.message ? e.message : String(e); }

                // reply
                try { event.source.postMessage({ id, result, error }, '*'); } catch (e) { /* ignore cross-origin */ }
                return;
            }

            // 2) Storyline sometimes posts LMSSetValue or LMSGetValue messages with different shapes
            if (data.messageType === 'LMSSetValue' || data.messageType === 'SetValue') {
                const name = data.name || data.key || data.element;
                const value = data.value || data.val;
                if (name) SCORM_API.LMSSetValue(name, value);
                return;
            }
            if (data.messageType === 'LMSGetValue' || data.messageType === 'GetValue') {
                const name = data.name || data.key || data.element;
                if (name) {
                    const v = SCORM_API.LMSGetValue(name);
                    try { event.source.postMessage({ messageType: 'LMSGetValueResult', name, value: v }, '*'); } catch (e) {}
                }
                return;
            }

            // 3) xAPI-like completion hints
            if (data.verb && (data.verb.id && data.verb.id.includes('completed') || data.result && data.result.completion)) {
                // map to SCORM completion
                SCORM_API.LMSSetValue('cmi.completion_status', 'completed');
                SCORM_API.LMSCommit('');
                return;
            }

            // 4) Generic fallbacks for LMS calls from older packages
            if (data.type === 'LMSCall' && data.method) {
                const method = data.method;
                const params = data.params || [];
                try {
                    if (SCORM_API[method]) {
                        const r = SCORM_API[method].apply(null, params);
                        try { event.source.postMessage({ type: 'LMSCallResult', method, result: r }, '*'); } catch (e) {}
                    }
                } catch (e) { }
                return;
            }

            // 5) Handle Storyline exit requests
            if (data.type === 'SCORM_EXIT_REQUEST') {
                console.log('Storyline exit request received');
                tryCommitBeforeExit();
                setTimeout(() => {
                    window.location.href = '{% url "courses:topic_view" topic.id %}';
                }, 500);
                return;
            }

        } catch (e) { console.error('Message handler error', e); }
    });

    // -----------------------
    // Before unload: try to commit progress
    // -----------------------
    function tryCommitBeforeExit() {
        try {
            if (window.API && window.API.LMSCommit) window.API.LMSCommit('');
            if (window.API_1484_11 && window.API_1484_11.Commit) window.API_1484_11.Commit('');
        } catch (e) { console.warn('Could not commit before unload:', e); }
    }
    window.addEventListener('beforeunload', tryCommitBeforeExit);
    window.addEventListener('pagehide', tryCommitBeforeExit);

    // -----------------------
    // Back button + save progress UX
    // -----------------------
    function handleBackToTopic(event) {
        event.preventDefault();
        const backBtn = document.getElementById('backToTopicBtn');
        if (backBtn) {
            backBtn.textContent = 'Saving progress...';
            backBtn.classList.add('disabled');
        }
        // Try to commit to backend and then navigate. Use setTimeout just to let sendBeacon run.
        tryCommitBeforeExit();
        setTimeout(() => {
            window.location.href = '{% url "courses:topic_view" topic.id %}';
        }, 250);
    }

    // -----------------------
    // Convenience: allow child frames to request the API by posting a discovery message
    // -----------------------
    window.addEventListener('message', function(event) {
        try {
            if (event.data && event.data.type === 'FindAPI') {
                try { event.source.postMessage({ type: 'FoundAPI', api: true }, '*'); } catch (e) {}
            }
        } catch (e) {}
    });

    // -----------------------
    // End of script
    // -----------------------
    </script>
</body>
</html>